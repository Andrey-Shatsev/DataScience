# ============================= Блок глобальных переменных =============================

# переменная координат:
dict_coord = {"a1": '.', "a2": '.', "a3": '.', "b1": '.', "b2": '.', "b3": '.', "c1": '.', "c2": '.', "c3": '.'}

# счетчик ходов:
step_number = 1

# служебная переменная - не дает возникать сообщению и игровой сетке, в случае ошибки на первом ходу
is_error = False

# переменная останавливающая игру, в случае победы, или ничьи.
game_over = False


# ============================= Блок графического интерфейса =============================
def show_game_grid():
    # рисование сеткии координат
    print("------------")
    print("|    1 2 3 |")
    print(f"| a  {dict_coord['a1']} {dict_coord['a2']} {dict_coord['a3']} |")
    print(f"| b  {dict_coord['b1']} {dict_coord['b2']} {dict_coord['b3']} |")
    print(f"| c  {dict_coord['c1']} {dict_coord['c2']} {dict_coord['c3']} |")
    print("------------")


# ============================= Функция для совершения хода текущего игрока =============================
def gamer_step(letter, text_for_step, player_number):
    global step_number
    global is_error

    if game_over is True:  # проверка на то, чтобы не допустить ход второго игрока, когда он уже проиграл.
        return

    if step_number == 1 and is_error is False:  # проверка для прописывания приветственной фразы.
        # дополнительно прописано условие - что не было ошибки, т.к. вы этом случае дублируется приветственная фраза
        # и сетка.
        print("Игра началась!")
        show_game_grid()
    x = input(text_for_step)
    try:  # начало отладки исключения
        if dict_coord[x] != '.':  # проверка на то, что поле свободно для совершения хода
            print("Выбранная ячейка занята! Выберите свободную ячейку для хода и повторите ввод.")
            is_error = True
            gamer_step(letter, text_for_step, player_number)
            return
        dict_coord[x] = letter
    except KeyError:  # описание действий, в случае выявления исключения.
        print('Ошибка, введите координаты в формате "a1" и повторите ввод')
        is_error = True
        gamer_step(letter, text_for_step, player_number)
        return  # команда нужна, чтобы функция не дублировала следующие после отлова исключения действия в этой функции
    print(f"Результат хода № {step_number}:")
    show_game_grid()
    step_number += 1
    win_draw_check(player_number, letter)


# ============================= Процедура проверки на наличие победы/ничьи =============================
def win_draw_check(arg, letter):
    global game_over
    global step_number

    # локальная переменная в виде листа с кортежами внутри задает все возможные выигрышные кобинации
    win_coordinates = [('a1', 'a2', 'a3'), ('b1', 'b2', 'b3'), ('c1', 'c2', 'c3'),
                       ('a1', 'b2', 'c3'), ('a3', 'a2', 'c1'),
                       ('a1', 'b1', 'c1'), ('a2', 'b2', 'c2'), ('a3', 'b3', 'c3')]

    # ниже проверка на наличие выигрышной кобинации из трех символов. Символ (x или o) зависит от того, чей ход.
    for each in win_coordinates:
        if dict_coord[each[0]] == dict_coord[each[1]] == dict_coord[each[2]] == letter:
            game_over = True
            print(f"Игра окончена ... Победил {arg}!")

    # проверка на то, что игра заходит в тупик и нужно выводить ничью
    if step_number >= 8:  # после того, как осталось два незаполненных поля и сложилась ситуация,что до сих пор никто
        # не выиграл - значит
        # никто и не выиграет. Игра заканчивается с Ничьей.
        game_over = True
        print("Игра окончена ... Ничья!")


# ============================= Функция проведения самой игры =============================
def begin_game():
    while game_over is False:
        gamer_step('x', 'Ход первого игрока. Укажите ячейку для крестика ("x") в формате "a1":', 'первый игрок')
        gamer_step("o", 'Ход второго игрока. Укажите ячейку для нолика ("o") в формате "a1": ', 'второй игрок')


begin_game()